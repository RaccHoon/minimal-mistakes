---
layout: single
title: "Brute Force 기본 개념"
categories: Algorithm_이론
tag: [Dev, Algorithm, C++]
author_profile: false
---

# Brute Force

## Brute Force 개요

- 입력의 크기가 작은 경우 컴퓨터의 연산 능력을 이용해 가능한 모든 경우를 일일이 나열하며 답을 찾는 방법이다.
- 알고리즘을 공부할수록 쉬운 문제를 어렵게 푸는 경우가 생긴다. 복잡하고 우아한 답안을 만들려 하다 보면 쉽고 간단하며 틀린 가능성이 낮은 답안을 간과하기 쉽다. 이런 실수를 피하기 위해 `brute force`를 이용해서  무식하게 풀 수 있는지 가장 먼저 고려해 봐야 한다.
- `brute force` 알고리즘은 종종 더 빠른 알고리즘의 기반이 되기도 한다.

## 재귀 함수

- 재귀 함수란 자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤, 그 중 한 조각을 수행하고, 나머지를 자기 자신을 호출해 실행하는 함수를 가리킨다.
- `brute force` 문제를 풀 때 반복문이나 재귀 함수를 사용할 수 있는데, 문제의 특성에 따라 재귀 호출을 이용했을 때 코딩이 간편해 지는 경우가 많다.

## 시간 복잡도

- `brute force` 알고리즘은 가능한 답 후보들을 모두 만들어 보기 때문에, 시간 복잡도를 계산하기 위해서는 가능한 후보의 수를 전부 세어보면 된다.
- 한 경우의 수를 계산하는데 필요한 연산 * 가능한 모든 경우의 수를 이용하면 다른 알고리즘에 비해 쉽게 시간 복잡도를 계산할 수 있다.
- `brute force` 알고리즘은 존재하는 모든 답을 하나씩 검사하므로, 걸리는 시간은 가능한 답의 수에 정확히 비례한다. 따라서 최대 크기의 입력을 가정했을 때 답의 개수를 계산하고, 이를 제한 시간 안에 처리할 수 있을지를 가늠해야 한다.
- 통상적으로 시간 제한이 1초일 때, 1억번의 연산을 초과하면 시간 초과의 가능성이 있다.

## 최적화 문제

- 문제의 답이 여러가지고, 그 중에서 어떤 기준에 따라 가장 좋은 답을 찾아 내는 문제를 `최적화 문제` 라고 한다.
- `brute force` 알고리즘은 `최적화 문제` 를 해결하기 위한 가장 기초적인 방법이다.

## 많이 등장하는 brute force 유형

### 모든 순열 만들기

- 주어진 원소의 모든 순열을 생성해 푸는 문제 유형
- 가능한 순열의 수는 N!이 되는데 N이 너무 크다면 시간 안에 모든 수열을 생성하기 어려우므로 다른 방법을 생각해야 한다.
- c++ 표준 라이브러리에 포함된 `next_permutation()` 함수에서 모든 순열을 순서대로 생성하는 작업을 대신 해준다.

### 모든 조합 만들기

- 가능한 조합의 개수는 nCr 이 되므로 시간 안에 풀 수 있을지 계산해야 한다.
- 재귀 함수로 쉽게 구할 수 있다.

### 2^n 가지 경우의 수 만들기

- n개의 질문에 대한 답이 예/아니오 중의 하나일 때 존재할 수 있는 답의 개수는 2^n 가지이다.
- 재귀 함수를 이용해 구할 수 있고, `비트 마스킹` 을 이용하면 좀 더 쉽게 모든 경우를 생성해 볼 수 있다.